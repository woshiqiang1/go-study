### interface(接口)

简单的说，interface 是一组 method 签名的组合，我们通过 interface 来定义对象的一组行为。

我们前面一章最后一个例子中 Student 和 Employee 都能 SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能 SayHi

让我们来继续做更多的扩展，Student 和 Employee 实现另一个方法 Sing，然后 Student 实现方法 BorrowMoney 而 Employee 实现 SpendSalary。

这样 Student 实现了三个方法：SayHi、Sing、BorrowMoney；而 Employee 实现了 SayHi、Sing、SpendSalary。

上面这些方法的组合称为 interface(被对象 Student 和 Employee 实现)。例如 Student 和 Employee 都实现了 interface：SayHi 和 Sing，也就是这两个对象是该 interface 类型。而 Employee 没有实现这个 interface：SayHi、Sing 和 BorrowMoney，因为 Employee 没有实现 BorrowMoney 这个方法。

#### interface 类型

语法：

```go
type 接口名称 interface {
	方法1名称(参数列表 ...) 返回值列表...
	方法2名称(参数列表 ...) 返回值列表...
	方法3名称(参数列表 ...) 返回值列表...
	...
	...
}
```

interface 类型定义了一组方法，**如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口**。详细的语法参考下面这个例子：

```go
type Human struct {
	name string
	age int
	phone string
}

type Student struct {
	Human //匿名字段Human
	school string
	loan float32
}

type Employee struct {
	Human //匿名字段Human
	company string
	money float32
}

//Human对象实现Sayhi方法
func (h *Human) SayHi() {
	fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

// Human对象实现Sing方法
func (h *Human) Sing(lyrics string) {
	fmt.Println("La la, la la la, la la la la la...", lyrics)
}

//Human对象实现Guzzle方法
func (h *Human) Guzzle(beerStein string) {
	fmt.Println("Guzzle Guzzle Guzzle...", beerStein)
}

// Employee重载Human的Sayhi方法
func (e *Employee) SayHi() {
	fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
		e.company, e.phone) //此句可以分成多行
}

//Student实现BorrowMoney方法
func (s *Student) BorrowMoney(amount float32) {
	s.loan += amount // (again and again and...)
}

//Employee实现SpendSalary方法
func (e *Employee) SpendSalary(amount float32) {
	e.money -= amount // More vodka please!!! Get me through the day!
}

// 定义interface
type Men interface {
    SayHi()
    Sing(lyrics string)
    Guzzle(beerStein string)
}

type YoungChap interface {
    SayHi()
    Sing(song string)
    BorrowMoney(amount float32)
}

type ElderlyGent interface {
    SayHi()
    Sing(song string)
    SpendSalary(amount float32)
}
```

通过上面的代码我们可以知道，interface 可以被任意的对象实现。我们看到上面的 Men interface 被 Human、Student 和 Employee 实现。同理，一个对象可以实现任意多个 interface，例如上面的 Student 实现了 Men 和 YoungChap 两个 interface。

最后，任意的类型都实现了空 interface(我们这样定义：interface{})，也就是包含 0 个 method 的 interface。

eg: 实现接口，调用方法

```go
package main

import (
    "fmt"
)

type Phone interface {
    call()
}

type NokiaPhone struct {
}

func (nokiaPhone NokiaPhone) call() {
    fmt.Println("I am Nokia, I can call you!")
}

type IPhone struct {
}

func (iPhone IPhone) call() {
    fmt.Println("I am iPhone, I can call you!")
}

func main() {
    var phone Phone

    phone = new(NokiaPhone)
    phone.call() // I am Nokia, I can call you!

    phone = new(IPhone)
    phone.call() // I am iPhone, I can call you!

}
```

#### 接口与隐式实现

类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。

隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。

因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。

```go
package main

import "fmt"

type I interface {
    M()
}

type T struct {
    S string
}

// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。
func (t T) M() {
    fmt.Println(t.S)
}

func main() {
    var i I = T{"hello"}
    i.M()
}
```

#### interface 值

接口也是值。它们可以像其它值一样传递。

接口值可以用作函数的参数或返回值。

在内部，接口值可以看做包含值和具体类型的元组：

> (value, type)

接口值保存了一个具体底层类型的具体值。

接口值调用方法时会执行其底层类型的同名方法。

```go
package main

import (
    "fmt"
    "math"
)

type I interface {
    M()
}

type T struct {
    S string
}

func (t *T) M() {
    fmt.Println(t.S)
}

type F float64

func (f F) M() {
    fmt.Println(f)
}

func main() {
    var i I

    i = &T{"Hello"}
    describe(i)
    i.M()

    i = F(math.Pi)
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf("(%v, %T)\n", i, i)
}
```

那么 interface 里面到底能存什么值呢？如果我们定义了一个 interface 的变量，那么这个变量里面可以存实现这个 interface 的任意类型的对象。例如上面例子中，我们定义了一个 Men interface 类型的变量 m，那么 m 里面可以存 Human、Student 或者 Employee 值。

因为 m 能够持有这三种类型的对象，所以我们可以定义一个包含 Men 类型元素的 slice，这个 slice 可以被赋予实现了 Men 接口的任意结构的对象，这个和我们传统意义上面的 slice 有所不同。

让我们来看一下下面这个例子:

```go
package main

import "fmt"

type Human struct {
	name string
	age int
	phone string
}

type Student struct {
	Human //匿名字段
	school string
	loan float32
}

type Employee struct {
	Human //匿名字段
	company string
	money float32
}

//Human实现SayHi方法
func (h Human) SayHi() {
	fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

//Human实现Sing方法
func (h Human) Sing(lyrics string) {
	fmt.Println("La la la la...", lyrics)
}

//Employee重载Human的SayHi方法
func (e Employee) SayHi() {
    fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name, e.company, e.phone)
}

// Interface Men被Human,Student和Employee实现
// 因为这三个类型都实现了这两个方法
type Men interface {
	SayHi()
	Sing(lyrics string)
}

func main() {
    mike := Student{Human{"Mike", 25, "222-222-XXX"}, "MIT", 0.00}
	paul := Student{Human{"Paul", 26, "111-222-XXX"}, "Harvard", 100}
	sam := Employee{Human{"Sam", 36, "444-222-XXX"}, "Golang Inc.", 1000}
	tom := Employee{Human{"Tom", 37, "222-444-XXX"}, "Things Ltd.", 5000}

    //定义Men类型变量
    var i Men

    //i能存储Student
    i = mike
    fmt.Println("This is Mike, a Student:")
    i.SayHi()
    i.Sing("November rain")

    //i也能存储Employee
	i = tom
	fmt.Println("This is tom, an Employee:")
	i.SayHi()
	i.Sing("Born to be wild")

    //定义了slice Men
    fmt.Println("Let's use a slice of Men and see what happens")
    x := make([]Men, 3)
    //这三个都是不同类型的元素，但是他们实现了interface同一个接口
    x[0], x[1], x[2] = paul, sam, mike

    for _, value := range x {
        value.SayHi()
    }
}
```

通过上面的代码，你会发现 interface 就是一组抽象方法的集合，它必须由其他非 interface 类型实现，而不能自我实现， Go 通过 interface 实现了 duck-typing:即"当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子"。

#### 底层值为 nil 的接口值

即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。

在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。

注意: 保存了 nil 具体值的接口其自身并不为 nil。
eg:

```go
package main

import "fmt"

type I interface {
    M()
}

type T struct {
    S string
}

func (t *T) M() {
    if t == nil {
        fmt.Println("<nil>")
        return
    }
    fmt.Println(t.S)
}

func main() {
    var i I

    var t *T
    i = t
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf("(%v, %T)\n", i, i)
}
```

#### nil 接口值

nil 接口值既不保存值也不保存具体类型。

为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 **具体** 方法的类型。

```go
package main

import "fmt"

type I interface {
	M()
}

func main() {
	var i I
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```

#### 空接口

指定了零个方法的接口值被称为**空接口**：

> interface {}

空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）

空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。
eg:

```go
package main

import "fmt"

func main() {
	var i interface{}
	describe(i) // (<nil>, <nil>)

	i = 42
	describe(i) // (42, int)

	i = "hello"
	describe(i) // (hello, string)
}

func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```

#### 编译检测规则

编译器会对接口方法的 `接收者参数` 进行检查，具体来说:

- 接收者形参为普通变量类型
  - 实参为普通变量类型，编译正常
  - 实参为指针变量类型，编译正常
- 接收者形参为指针变量类型
  - 实参为普通变量类型，编译报错，因为编译器不会无缘无故创建一个新的指针，退一步说，即使编译器可以创建指针指向变量，但是因为 Go 语言传递参数方式为 值传递，此时新指针指向的变量，并不是调用该方法的变量，而是经过复制传递的参数变量。
  - 实参为指针变量类型，编译正常

#### Stringer

fmt 包中定义的 Stringer 是最普遍的接口之一。

```go
type Stringer interface {
    String() string
}
```

Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。

```go
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

func main() {
	a := Person{"Arthur Dent", 42}
	z := Person{"Zaphod Beeblebrox", 9001}
	fmt.Println(a, z) // Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)
}
```

Test: Stringer
通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。
例如，IPAddr{1, 2, 3, 4} 应当打印为 "1.2.3.4"。

```go
package main

import "fmt"

type IPAddr [4]byte

// 给 IPAddr 添加一个 "String() string" 方法
func (ip IPAddr) String() string {
	return fmt.Sprintf("%d.%d.%d.%d",ip[0], ip[1], ip[2], ip[3])
}

func main() {
	hosts := map[string]IPAddr{
		"loopback":  {127, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}
	for name, ip := range hosts {
		fmt.Printf("%v: %v\n", name, ip)
	}
}
```

#### 实现系统错误接口

标准库 `error` 数据类型本质上就是一个接口，原型如下:

```go
package builtin

type error interface {
	Error() string
}
```

eg: 实现 error 接口

```go
package main

import "fmt"

type divideError struct {
    msg string
}

// 实现 error interface
func (d *divideError) Error() string {
    return d.msg
}

func newDivideError()  *divideError {
    return &divideError{
        msg: "divide by zero",
    }
}

func myDivide(dividend, divisor float64) (float64, error) {
    if divisor == 0 {
        return 0, newDivideError()
    }

    return dividend / divisor, nil
}

func main() {
    divide, err := myDivide(100, 0)
    if err != nil {
        fmt.Printf("Error: %s\n", err)
    } else {
        fmt.Printf("100 / 0 = %.2f\n", divide)
    }
}

// $ go run main.go
// 输出如下
/**
  Error: divide by zero
*/
```

#### 判断是否实现接口

Go 里面没有 `implements` 关键字来判断一个结构体 (对象) 是否实现了某个接口， 要实现类似的功能， 需要用到**类型断言**。

eg: 类型断言

```go
// 判断 v 是否实现了接口 i
// 返回值 ok 为 true 表示已实现，ok 为 false 表示未实现
if _, ok := v.(i); ok {
// do something...
}
```

eg: 判断是否实现接口

```go
package main

import "fmt"

type geometry interface {
	area() float64
	perimeter() float64
}

type rectangle struct {
	width, height float64
}

type circle struct {
	radius float64
}

func (r *rectangle) area() float64 {
	return r.width * r.height
}

func (r *rectangle) perimeter() float64 {
	return (r.width + r.height) * 2
}

func main() {
	var r interface{}

	r = &rectangle{
		width:  10,
		height: 5,
	}
	if v, ok := r.(geometry); ok {
		fmt.Printf("r implements interface geometry, area = %.2f, perimeter = %.2f \n", v.area(), v.perimeter())
	}

	var c interface{}
	c = &circle{
		radius: 10,
	}
	if _, ok := c.(geometry); !ok {
		fmt.Println("c does not implement interface geometry")
	}
}

// $ go run main.go
// 输出如下
/**
  r implements interface geometry, area = 50.00, perimeter = 30.00
  c does not implement interface geometry
*/
```
